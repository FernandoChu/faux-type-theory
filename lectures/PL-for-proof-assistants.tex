\documentclass[10pt]{beamer}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pgfpages}
\usepackage{xcolor}
\usepackage{xypic}
\usepackage{upgreek}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{mathpartir}

\usepackage{palatino}
% \usepackage{xypic}
\usepackage{amsfonts}
%\usepackage[llbracket,rrbracket]{stmaryrd}
\usepackage{pgfpages}

\mode<presentation>
% \Usetheme{Goettingen}
\usecolortheme{rose}
\usefonttheme{serif}
\setbeamertemplate{navigation symbols}{}

% Frame number
\setbeamertemplate{footline}[frame number]{}

% These slides also contain speaker notes. You can print just the slides,
% just the notes, or both, depending on the setting below. Comment out the want
% you want.

\setbeameroption{hide notes} % Only slides
%\setbeameroption{show only notes} % Only notes
%\setbeameroption{show notes on second screen=right} % Both

% Give a slight yellow tint to the notes page
\setbeamertemplate{note page}{\pagecolor{yellow!5}\insertnote}\usepackage{palatino}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MACROS

%% Typing judgements & rules
\newcommand{\emptyctx}{{\cdot}} % empty context
\newcommand{\typingrule}[2]{\infer{#1}{#2}}
\newcommand{\of}{\,{:}\,} % typing of a variable in a context
\newcommand{\types}{\vdash} % the turnstile

\newcommand{\Type}{\mathsf{Type}}
\newcommand{\prd}[1]{\Uppi_{(#1)}}
\newcommand{\lam}[1]{\lambda (#1).\,}

\newcommand{\letin}[3]{\mathsf{let}\,#1\,{{:}{=}}\,#2\,\mathsf{in}\,#3}

%%%%%%% GROUP: named inference rules

% the style for rule names
\newcommand{\rulename}[1]{\textnormal{\textsc{#1}}}

% use \rref{...} to refer to a rule in text
\newcommand{\rref}[1]{\hyperlink{rule:#1}{\rulename{#1}}}

% the color of rule names
\definecolor{rulenameColor}{rgb}{0.5,0.5,0.5}

% named inference rule
\newcommand{\inferenceRule}[3]{\inferrule*[lab={\hypertarget{rule:#1}{\rulename{\footnotesize\color{rulenameColor}#1}}}]{#2}{#3}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Programming language techniques\\ for proof assistants}
\author{Andrej Bauer\\University of Ljubljana}
\date{}
\begin{document}

\begin{frame}
\hbox{}\vfil

\titlepage

\vfil

\begin{center}
\footnotesize
International School on Logical Frameworks and Proof Systems Interoperability \\
Université Paris--Saclay, September 8--12, 2025
\end{center}

\end{frame}


\begin{frame}
  \frametitle{Overview}

  \begin{itemize}
  \item Lecture 1: The anatomy of a proof checker
    \begin{itemize}\footnotesize
    \item A toy type theory
    \item Components of a proof checker
    \item Monadic-style implementation
    \end{itemize}
  \item \pause
    Lecture 2: Meta-variables and unification
    \begin{itemize}\footnotesize
    \item What are meta-variables?
    \item What is unification?
    \item The wrong implementation
    \end{itemize}
  \item \pause
    Lecture 3: Algebraic effects and handlers
    \begin{itemize}\footnotesize
    \item Algebraic theories
    \item Algebraic effects and handlers
    \item Effects and handlers in OCaml
    \end{itemize}
  \item \pause
    Lecture 4: Effects in a proof assistant
    \begin{itemize}\footnotesize
    \item Meta-variables as promises
    \item Proof assistant as a scheduler
    \end{itemize}
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \begin{center}
    \Huge Lecture 1

    \bigskip

    \Large
    The anatomy of a proof checker
  \end{center}
\end{frame}

% Faux type theory
% - rules
% - computation and extensionality rules (η-rules)

\begin{frame}
  \frametitle{Faux Type Theory -- judgement forms}


  \begin{itemize}
  \item
    Judgement forms:
    %
    {\small
    \begin{tabbing}
      $\Gamma \vdash t : A$ \qquad\qquad \= ``In context $\Gamma$ term $t$ has type $A$.'' \\
      $\Gamma \vdash t \equiv_A u$ \> ``In context $\Gamma$ terms $t$ and $u$ of type $A$ are equal.''
    \end{tabbing}}
    % 
  \item \pause
    In the name of simplicity, we shall abuse ``$\Type : \Type$''.
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Faux Type Theory -- terms and types}

  \begin{mathpar}
    \inferenceRule{Ty-Type}
    { }
    {\Gamma \types \Type : \Type}

    \inferenceRule{Ty-Pi}
    {\Gamma, x \of A \types B(x) : \Type}
    {\Gamma \types \prd{x \of A} B(x) : \Type}

    \\

    \inferenceRule{Tm-App}
    {\Gamma \types t : \prd{x \of A} B(x)
      \\
      \Gamma \types u : A
    }{
      \Gamma \types t\,u : B(u)
    }

    \inferenceRule{Tm-Lambda}
    {\Gamma, x \of A \types t(x) : B(x)}
    {\Gamma \types \lam{x \of A} t(x) : \prd{x \of A} B(x)}

    \\

    \inferenceRule{Tm-Var}
    {(x \of A) \in \Gamma}
    {\Gamma \types x : A}


    \inferenceRule{Tm-Let}
    {\Gamma \types t : A
      \\
      \Gamma, x \,{:}{=}\, t \of A \types u(x) : B(x)
    }{
      \Gamma \types (\letin{x}{t}{u}) : B(t)
    }
  \end{mathpar}

  \note{Discuss presuppositions}
  \note{Discuss absence of $\Gamma$}

\end{frame}


\begin{frame}
  \frametitle{Faux Type Theory -- equality}

  \begin{mathpar}

    \inferenceRule{Eq-Refl}
    {\Gamma \types t : A}
    {\Gamma \types t \equiv_A t}

    \inferenceRule{Eq-Sym}
    {\Gamma \types u \equiv_A t}
    {\Gamma \types t \equiv_A t}

    \inferenceRule{Eq-Tran}
    {\Gamma \types s \equiv_A t \\
     \Gamma \types t \equiv_A u}
    {\Gamma \types s \equiv_A t}

    \\

    \inferenceRule{Eq-Conv}
    {\Gamma \types t : A \\ \types A \equiv_\Type B}
    {\Gamma \types t : B}

    \\

    \inferenceRule{Eq-Beta}
    {\Gamma, x \of A \types t(x) : B(x)
      \\
      \Gamma \types u : A
    }{
      \Gamma \types (\lam{x \of A} t(x))\,u \equiv_{B(u)} t(u)
    }

    \inferenceRule{Eq-Ext}
    {\Gamma, x \of A \types t\,x \equiv_{B(x)} u\,x : B(x)}
    {\Gamma \types t \equiv_{\prd{x \of A} B(x)} u}


    \inferenceRule{Eq-Var}
    {(x \,{:}{=}\, t \of A) \in \Gamma}
    {\Gamma \types x \equiv_A t}

    \inferenceRule{Eq-Let}
    {
      \Gamma \types t : A
      \\
      \Gamma, x \,{:}{=}\, t \of A \types u(x) : B(x)
    }{
      \Gamma \types (\letin{x}{t}{u(x)}) \equiv_{B(t)} u(t)
    }

  \end{mathpar}

  \note{Discuss presuppositions}
  \note{Discuss absence of $\Gamma$}

\end{frame}


% Components of a proof checker
% - syntax: parser, variable binding & printing
% - type-checker
% - top level

\begin{frame}
  \frametitle{The components of a proof assistant}

  \begin{itemize}
  \item Parsing of concrete syntax
  \item Variable binding \& substitution
  \item Type-checking
  \item Top level
  \end{itemize}
\end{frame}


% Implementation
% - parsing with Menhir
% - abstract syntax: Bindlib
% - computing in context
% - monadic-style type-checker


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \begin{center}
    \Huge Lecture 2

    \bigskip

    \Large
    Meta-variables and unification
  \end{center}
\end{frame}

% What are meta-variables?
% Where are they used?
% Implementation monadic-style


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \begin{center}
    \Huge Lecture 3

    \bigskip

    \Large
    Algebraic effects and handlers
  \end{center}
\end{frame}

% Algebraic effects and handler - blitz intro
% - algebraic theory
% - effects as algebraic theories
% - handlers
% - OCaml implementation


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \begin{center}
    \Huge Lecture 4

    \bigskip

    \Large
    Effects in proof assistants
  \end{center}
\end{frame}

% Meta-variables as promises
% Handlers: 

\end{document}
